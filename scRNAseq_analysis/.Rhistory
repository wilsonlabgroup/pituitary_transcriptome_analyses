setwd("~/Documents/GitHub/pituitary_transcriptome_analyses/scRNAseq_analysis")
library(dplyr)
library(Seurat)
library(knitr)
library(biomaRt)
library(scales)
library(EDASeq)
library(pheatmap)
library(LaCroixColoR)
library(grid)
library(plyr)
library(ggpubr)
library(reshape2)
library(ggplot2)
library(colorspace)
library(ggrepel)
library(openxlsx)
source("cheung_sc_reprocess_2021-03-22_functions_rmd_ver.R")
pit_data <- Read10X(data.dir = "~/Dropbox (Wilson Lab)/Mike_Anna_Mark/active_manuscript/Pituitary paper/scripts/single_cell_rmd/input_files/GSE120410_Cheung_2018/")
# pit_data <- Read10X(data.dir = "~/Dropbox (Wilson Lab)/Mike_Anna_Mark/active_manuscript/Pituitary paper/scripts/single_cell_rmd/input_files/GSE120410_Cheung_2018/")
pit_seurat <- CreateSeuratObject(counts = pit_data,
project = "cheung_pit",
min.cells = 3,
min.features = 200)
pit_seurat
pit_seurat[["percent.mt"]] <- PercentageFeatureSet(pit_seurat, pattern = "^mt-")
print(VlnPlot(pit_seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3))
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(pit_seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pit_seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
print(plot1+plot2)
#+ data_postfilt, warning = F, message = F, fig.cap = "Visualization of QC metrics after filtering", fig.width = 10, fig.height = 8
# Apply filter to data based on QC metrics
pit_seurat <- subset(pit_seurat, subset = nFeature_RNA > 200 & nFeature_RNA < 7000 & percent.mt < 20)
pit_seurat # After subsetting with filter
print(VlnPlot(pit_seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3))
plot1 <- FeatureScatter(pit_seurat, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pit_seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
print(plot1+plot2)
#' ## SCTransform data normalization
pit_seurat <- SCTransform(pit_seurat, vars.to.regress = "percent.mt")
warnings()
#' ## Data scaling
#' Linear transformation 'scaling' prior to dimensional reduction like PCA shifts expression of each gene so mean expression across cells is 0.
#' Scales gene expression for each gene so that variance across cells is 1 (so that highly expressed genes do not dominate).
#+ data_scaling, warning = F, message = F
#### Data scaling ####
all.genes <- rownames(pit_seurat)
pit_seurat <- ScaleData(pit_seurat, features = all.genes) # pit_seurat[["RNA"]]@scale.data
pit_seurat <- RunPCA(pit_seurat, features = VariableFeatures(object = pit_seurat))
print(pit_seurat[["pca"]], dims = 1:5, nfeatures = 5)
print(VizDimLoadings(pit_seurat, dims = 1:5, reduction = "pca"))
#+ pca_dim_plot, warning = F, message = F, fig.cap = "Top 2 principal components of data.", fig.width = 10, fig.height = 10
DimPlot(pit_seurat, reduction = "pca")
#+ pca_dim_htmap, warning = F, message = F, fig.cap = "Expression of genes associated with the first 15 principal components.", fig.width = 10, fig.height = 10
DimHeatmap(pit_seurat, dims = 1:15, cells = 500, balanced = TRUE)
#' ## Determining "dimensionality" of dataset
#' Cells are clustered based on their PCA scores where each PC is a "metafeature" that combines info across correlated feature set.
#' To determine the number of PCs to use, an Elbow Plot is generated.
#' The elbow plot ranks the principle components based on % variance explained by each one.
#' The point at which we observe an 'elbow' or decrease in steepness of the line suggests that the majority of true signal is captured before this point.
#' Here we observe the elbow around PC15, hence we will use 15 PCs for our downstream analysis.
#+ elbow_plot, warning = F, message = F, fig.cap = "Elbow plot ranking principal components."
#### Elbow plot ####
print(ElbowPlot(pit_seurat))
#' ## Cell clustering
#' Graph-based clustering approach where genes which similar feature expression patterns have edges drawn between them.
#' Partition of graph into "communities" where nodes/genes are highly interconnected is then applied after.
#' First, K-nearest neighbour (KNN) graph based on euclidean distance in PCA space is constructed.
#' Second, edge weights between cells are refined based on shared overlap in 'local neighbourhood' (Jaccard similarity).
#' This second step takes in as input the previously defined dimensionality of the dataset (first 15 PCs).
#+ cell_clustering, warning = F, message = F
#### Cell clustering ####
pit_seurat <- FindNeighbors(pit_seurat, dims = 1:15)
#' To cluster the cells, Louvain algorithm is applied.
#' Cells are grouped together iteratively, with goal of optimizing standard modularity function.
#' Resolution increases for larger datasets and increases the number of clusters resulting.
#' Here, 14 cell clusters result.
#' From the previous version, the resolution was changed to 0.2.
#+ find_clusters, warning = F, message = F
#### Louvain algorithm ####
pit_seurat <- FindClusters(pit_seurat, resolution = 0.2)
head(Idents(pit_seurat), 5)
#' ## Non-linear dimensionality reduction
#' UMAP reduce dimensions of the data and allow for visualization of the dataset in 2D space.
#' These algorithms try to learn the underlying manifold of the data to try to place similar cells together in low-dim space.
#+ umap_dim_red, warning = F, message = F, fig.show="hold", out.width="50%", fig.cap = "UMAP visualization of cell clusters.", fig.width = 28, fig.height = 14
#### Non-linear dimensional reduction ####
pit_seurat <- RunUMAP(pit_seurat, dims = 1:15)
p1 <- DimPlot(pit_seurat, reduction = "umap", label = T)
print(p1)
dir.create("output_files")
p1 <- DimPlot(pit_seurat, reduction = "umap", label = T)
p2 <- DimPlot(pit_seurat, reduction = "umap", label = F)
pdf("output_files/seurat_v4_sctransform_cheungpit_umap.pdf", width = 7, height = 6)
print(p1)
print(p2)
tmp <- dev.off()
print(p1+p2)
#' Differential expression of genes within different clusters is tested to identify gene markers for each cluster.
#' Positive gene markers are identified for each cluster.
#' Only genes which are detected in >25% in either one of the two clusters of a given comparison are used.
#' The default Wilcoxon test is used with logFC threshold of 0.25.
#' Violin plots and UMAP are used to visualize known anterior hormone-producing cell-type markers in each cluster.
#' Other pituitary cell-type markers are also visualized (pituicytes, FSCs, endothelial cells).
#' Finally, the top 10 expressing genes in each cluster is plotted as a heatmap.
#+ find_markers, warning = F, message = F
#### Find cluster biomarkers ####
# pit_seurat <- readRDS("output_files/seurat_v3_pitCheung.rds")
Idents(pit_seurat) <- pit_seurat$seurat_clusters
pit_markers <- FindAllMarkers(pit_seurat, only.pos = T, min.pct = 0.25)
kable(head(pit_markers), caption = "Example cluster gene markers identified.")
write.table(pit_markers, "output_files/seurat_v4_sctransform_cheungpit_allposmarker_genes.txt",
sep = "\t", col.names = T, row.names = F, quote = F)
View(pit_markers)
p <- VlnPlot(pit_seurat, features = c("Gh", "Prl", "Lhb", "Fshb", "Tshb", "Pomc", "Crhr1", "Pax7", "Oacyl", "Sox2", "Rbpms", "Pou1f1",
"Top2a", "Mki67", "Plvap", "Meis2", "Emcn", "Dcn", "Lama2", "C1qa", "Ctss",
"Scn7a", "Col25a1"), pt.size = 0.5)
print(p)
pdf("output_files/seurat_marker_plots/sctransform_cheungpit_markers_violin.pdf", width = 20, height = 20)
print(p)
tmp <- dev.off()
ggsave("output_files/seurat_marker_plots/sctransform_cheungpit_markers_violin.png", p, width = 20, height = 25)
#+ plot_markers_umap, message = F, warning = F, fig.cap = "UMAP of pituitary gene markers.", fig.width = 13, fig.height = 8
p <- FeaturePlot(pit_seurat, features = c("Gh", "Prl", "Lhb", "Fshb", "Tshb", "Pomc", "Crhr1", "Pax7", "Oacyl", "Sox2", "Rbpms", "Pou1f1",
"Top2a", "Mki67", "Plvap", "Meis2", "Emcn", "Dcn", "Lama2", "C1qa", "Ctss",
"Scn7a", "Col25a1"), reduction = "umap")
print(p)
pdf("output_files/seurat_marker_plots/sctransform_cheungpit_markers_umap.pdf", width = 20, height = 25)
print(p)
tmp <- dev.off()
ggsave("output_files/seurat_marker_plots/sctransform_cheungpit_markers_umap.png", p, width = 20, height = 25)
#+ plot_top10_heatmap, message = F, warning = F, fig.cap = "Heatmap of top 10 gene markers in each cell cluster.", fig.width = 12, fig.height = 12
top10 <- pit_markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)
p <- DoHeatmap(pit_seurat, features = top10$gene) + NoLegend()
print(p)
pdf("output_files/seurat_marker_plots/sctransform_cheungpit_TOP10markers_heatmap.pdf", width = 12, height = 12)
print(p)
tmp <- dev.off()
ggsave("output_files/seurat_marker_plots/sctransform_cheungpit_TOP10markers_heatmap.png", p, width = 20, height = 25)
#+ plot_thyro_heatmap, message = F, warning = F, fig.cap = "UMAP of thyrotropes gene markers based on list in Cheung et al 2018.", fig.width = 10, fig.height = 8
p <- FeaturePlot(pit_seurat, features = c("Tshb", "Trhr", "Dio2"), reduction = "umap")
print(p)
pdf("output_files/seurat_marker_plots/sctransform_cheungpit_thryotropes_markers_umap.pdf", width = 10, height = 8)
print(p)
tmp <- dev.off()
ggsave("output_files/seurat_marker_plots/sctransform_cheungpit_thryotropes_markers_umap.pdf", p, width = 10, height = 8)
new_cluster_ids <- c(`0`="Somatotropes_0", #0
`1`="Lactotropes",#1
`2`="Somatotropes_1",#2
`3`="Corticotropes",#3
`4`="Gonadotropes",#4
`5`= "Somatotropes_2",#5
`6`= "Stem_cells_Sox2", #6
`7`="Endothelial", #7
`8`="Proliferating", #8
`9`="Melanotropes", #9
`10`="Pericytes", #10
`11`="Macrophages", #11
`12`="Pituicytes") #12
pit_seurat <- RenameIdents(pit_seurat, new_cluster_ids)
#' ## Visualization of manually labelled cell clusters
#' UMAPs are revisualized with manually labelled clusters.
#+ umap_manual, message = F, warning = F, fig.show="hold", out.width="50%", fig.cap = "UMAP visualization of manually labelled cell clusters.", fig.width = 28, fig.height = 14
#### Manual cell cluster UMAP ####
p1 <- DimPlot(pit_seurat, reduction = "umap", label = T)
p2 <- DimPlot(pit_seurat, reduction = "umap", label = F)
print(p1+p2)
pdf("output_files/sctransform_cheungpit_umap_manual_celltypes.pdf", width = 10, height = 10, useDingbats = F)
print(p1)
print(p2)
tmp <- dev.off()
#' ## Merge manual cluster labelling
#' Manually labelled clusters are merged based on cell type.
#+ merge_manual_label, message = F, warning = F
#### Merge manual cluster ####
pit_seurat$manual_anno <- Idents(pit_seurat)
merge_cluster_ids <- c(Somatotropes_0 = "Somatotropes", #0
Lactotropes = "Lactotropes", #1
Somatotropes_1 = "Somatotropes",#2
Gonadotropes = "Gonadotropes",#3
Corticotropes = "Corticotropes",#4
Thyrotropes = "Thyrotropes", #5
Stem_cells_Sox2 = "Stem_cells_Sox2",#6
Proliferating = "Proliferating", #7
Endothelial = "Endothelial", #8
Melanotropes = "Melanotropes", #9
Pericytes = "Pericytes", #10
Macrophages = "Macrophages", #11
Pituicytes = "Pituicytes") #12
pit_seurat <- RenameIdents(pit_seurat, merge_cluster_ids)
merge_cluster_ids <- c(Somatotropes_0 = "Somatotropes", #0
Lactotropes = "Lactotropes", #1
Somatotropes_1 = "Somatotropes",#2
Corticotropes = "Corticotropes",#3
Gonadotropes = "Gonadotropes",#4
Somatotropes_2 = "Somatotropes", #5
Stem_cells_Sox2 = "Stem_cells_Sox2",#6
Endothelial = "Endothelial", #7
Proliferating = "Proliferating", #8
Melanotropes = "Melanotropes", #9
Pericytes = "Pericytes", #10
Macrophages = "Macrophages", #11
Pituicytes = "Pituicytes") #12
pit_seurat <- RenameIdents(pit_seurat, merge_cluster_ids)
Idents(pit_seurat) <- pit_seurat$manual_anno
merge_cluster_ids <- c(Somatotropes_0 = "Somatotropes", #0
Lactotropes = "Lactotropes", #1
Somatotropes_1 = "Somatotropes",#2
Corticotropes = "Corticotropes",#3
Gonadotropes = "Gonadotropes",#4
Somatotropes_2 = "Somatotropes", #5
Stem_cells_Sox2 = "Stem_cells_Sox2",#6
Endothelial = "Endothelial", #7
Proliferating = "Proliferating", #8
Melanotropes = "Melanotropes", #9
Pericytes = "Pericytes", #10
Macrophages = "Macrophages", #11
Pituicytes = "Pituicytes") #12
pit_seurat <- RenameIdents(pit_seurat, merge_cluster_ids)
#' ## Visualization of merged manually labelled cell clusters
#' UMAPs are revisualized with merged manually labelled clusters.
#+ merge_umap_manual, message = F, warning = F, fig.show="hold", out.width="50%", fig.cap = "UMAP visualization of merged manually labelled cell clusters.", fig.width = 28, fig.height = 14
#### Merged manual cell cluster UMAP ####
p1 <- DimPlot(pit_seurat, reduction = "umap", label = T)
p2 <- DimPlot(pit_seurat, reduction = "umap", label = F)
print(p1+p2)
pdf("output_files/sctransform_cheungpit_umap_merged_manual_celltypes.pdf", width = 10, height = 10, useDingbats = F)
print(p1)
print(p2)
tmp <- dev.off()
#' ## Manually labelled cluster gene marker identification
#' Gene markers are reidentified using manually grouped cell clusters.
#' The same parameters are run with FindAllMarkers.
#' Additionally, both positive and negative gene markers are identified for downstream analyses purposes (scMappR).
#+ manual_find_marker, message = F, warning = F
#### Manual marker identification ####
pos_markers <- FindAllMarkers(pit_seurat, only.pos = T, min.pct = 0.25)
kable(head(pos_markers), caption = "Example manual cluster gene markers identified.")
write.table(pos_markers, "output_files/seurat_v4_sctransform_cheung_etal_manual_anno_cell_cluster_allposmarkers.txt", sep = "\t", quote = F,col.names = T, row.names = F)
man_markers <- FindAllMarkers(pit_seurat, only.pos = F, min.pct = 0.25)
write.table(man_markers, "output_files/seurat_v4_sctransform_cheung_etal_manual_anno_cell_cluster_allmarkers.txt", sep = "\t", quote = F,col.names = T, row.names = F)
View(pos_markers)
#' ## Save manually labelled Seurat object
#' Overwrites previous object
#+ save_manual_seurat, message = F, warning = F
saveRDS(pit_seurat, "output_files/seurat_v4_sctransform_pitCheung.rds")
seurat <- pit_seurat
# seuratman <- pit_seurat_manual
clusters <- seurat$RNA_snn_res.0.2
manclusters <- Idents(seurat)
mod_utr <- readRDS("input_files/pit_utrseq_coexpression_modules_annotation.rds")
mod_utr$modules <- factor(mod_utr$modules)
celltypes <- merge_cluster_ids
# Create colour palette for heatmap annotation of cell types
ggcolours <- hue_pal()(12)
names(ggcolours) <- levels(manclusters)
celltypes_col <- celltypes
for(i in 1:length(celltypes_col)) {
celltypes_col[i] <- ggcolours[celltypes_col[i]]
}
names(celltypes_col) <- as.character(celltypes)
#' ## Run KS test for all cell clusters
#' KS test is run and FDR is calculated for each module gene in each cell cluster (not manually labelled).
#' Genes with enriched with FC > 0, FDR adj < 0.05 in at least one cell cluster compared to all other clusters are retained.
#' Heatmap is plotted with FDR value for each module gene retained in each cell cluster.
#+ run_ks_test, warning = F, message = F
#Run KS test and calculate FDR for each module gene
ks_res <- lapply(levels(mod_utr$modules), function(x) calc_stat_test(mod_utr[mod_utr$modules == x, "genename"], "ks", seurat, clusters))
ks_respval <- lapply(ks_res, function(x) na.exclude(x[["pval"]]))
num_comparisons <- sum(unlist(lapply(ks_respval, function(x) print(as.numeric(dim(x)[1]) * as.numeric(dim(x)[2])))))
#Calculate FDR adjusted pvalue and filter for minimum FDR adj < 0.05 in each row
ks_resfdr <- lapply(ks_respval, function(x) matrix(p.adjust(as.matrix(x), method = "fdr", n = sum(num_comparisons)), nrow = nrow(x), ncol = ncol(x), dimnames = dimnames(x)))
ks_fdrcut <- lapply(ks_resfdr, function(x) x[rowMin(x) <= 0.05, ])
#Filter FC calculated so that only genes with FC > 0 in at least one comparison is included
ks_fc <- lapply(ks_res, function(x) na.exclude(x[["FC"]]))
names(ks_fdrcut) <- names(ks_fc) <- paste0("M", 1:9)
ks_fccut <- lapply(names(ks_fc), function(x) ks_fc[[x]][rownames(ks_fc[[x]]) %in% rownames(ks_fdrcut[[x]]), ])
ks_fccut <- lapply(ks_fccut, function(x) x[abs(rowSums(x)) > 0, ])
#Combine FDR df from all modules into one df
all_ks <- bind_rows(lapply(ks_fdrcut, function(x) as.data.frame(cbind("gene" = rownames(x), x))))
rownames(all_ks) <- all_ks$gene
all_ks <- all_ks[, -1]
gene_names <- rownames(all_ks)
all_ks <- sapply(all_ks, function(x) as.numeric(as.character(x)))
rownames(all_ks) <- gene_names
#Annotate each gene to corresponding module
anno_row <- bind_rows(lapply(names(ks_fdrcut), function(x) as.data.frame(cbind("gene" = rownames(ks_fdrcut[[x]]), "module" = x) )))
rownames(anno_row) <- anno_row$gene
anno_col <- list(celltype = ggcolours)
#Calculate breaks in heatmap based on modules
indices <- sapply(ks_fdrcut, nrow)
for(i in 2:length(indices)) {
x <- as.numeric(indices[i])
indices[i] <- as.numeric(indices[i - 1]) + as.numeric(indices[i])
}
cell_anno <- as.data.frame(cbind("cluster" = 0:12, "celltype" = celltypes))
rownames(cell_anno) <- cell_anno$cluster
use_breaks <- get_htmap_breaks(all_ks)
#+ ks_heatmap_all_clusters, warning = F, message = F, width = 8, height = 10, fig.cap = "Cell clusters are clustered based on similarity."
p <- pheatmap(all_ks,
# border_color = "black",
color = colorRampPalette(c("darkmagenta", "snow2"))(250),
annotation_col = cell_anno[, 2, drop = F],
cluster_rows = F,
cluster_cols = T,
# scale = "row",
annotation_colors = anno_col,
gaps_row = indices,
show_rownames = F,
labels_col = paste(cell_anno$cluster, cell_anno$celltype)
# breaks = use_breaks2,
)
save_phtmap_pdf(p, "output_files/pit_utr_module_cheung_scrna_ks_FDR_cellenrichment.pdf", 8, 10)
print(p)
tmp <- dev.off()
#+ ks_heatmap_all_clusters_ordered, warning = F, message = F, width = 8, height = 10, fig.cap = "Cell clusters are clustered based on manual cell-type annotation."
all_ks_fdr <- bind_rows(lapply(ks_fdrcut, function(x) as.data.frame(cbind("gene" = rownames(x), x))))
rownames(all_ks_fdr) <- all_ks_fdr$gene
all_ks_fdr <- all_ks_fdr[, -1]
gene_names <- rownames(all_ks_fdr)
all_ks_fdr <- sapply(all_ks_fdr, function(x) as.numeric(as.character(x)))
rownames(all_ks_fdr) <- gene_names
indices <- sapply(ks_fdrcut, nrow)
for(i in 2:length(indices)) {
x <- as.numeric(indices[i])
indices[i] <- as.numeric(indices[i - 1]) + as.numeric(indices[i])
}
cell_anno <- as.data.frame(cbind("cluster" = 0:12, "celltype" = celltypes))
rownames(cell_anno) <- cell_anno$cluster
all_ks_fdr_order <- all_ks_fdr[, order(cell_anno$celltype)]
p <- pheatmap(all_ks_fdr_order,
# border_color = "black",
color = colorRampPalette(c("darkmagenta", "snow3"))(250),
annotation_col = cell_anno[, 2, drop = F],
cluster_rows = F,
cluster_cols = F,
# scale = "row",
annotation_colors = anno_col,
gaps_row = indices,
show_rownames = F
# breaks = use_breaks,
)
save_phtmap_pdf(p, "output_files/pit_utr_module_cheung_scrna_ks_FDR_cellenrichment_cellordered.pdf", 8, 10)
print(p)
tmp <- dev.off()
#' ## Run KS test for manually annotated cell-types
#' KS test is run and FDR is calculated for each module gene in each manually annotated cell-type.
#' Genes with enriched with FC > 0, FDR adj < 0.05 in at least one cell-type compared to all other cell-types are retained.
#' Heatmap is plotted with FDR value for each module gene retained in each cell-type.
#+ run_ks_test_manual, warning = F, message = F
#### KS test manual annotation ####
#Run KS test and calculate FDR for each module gene
ks_res <- lapply(levels(mod_utr$modules), function(x) calc_stat_test(mod_utr[mod_utr$modules == x, "genename"], "ks", seurat, manclusters))
ks_respval <- lapply(ks_res, function(x) na.exclude(x[["pval"]]))
num_comparisons <- sum(unlist(lapply(ks_respval, function(x) print(as.numeric(dim(x)[1]) * as.numeric(dim(x)[2])))))
#Calculate FDR adjusted pvalue and filter for minimum FDR adj < 0.05 in each row
ks_resfdr <- lapply(ks_respval, function(x) matrix(p.adjust(as.matrix(x), method = "fdr", n = sum(num_comparisons)), nrow = nrow(x), ncol = ncol(x), dimnames = dimnames(x)))
ks_fdrcut <- lapply(ks_resfdr, function(x) x[rowMin(x) <= 0.05, ])
#Filter FC calculated so that only genes with FC > 0 in at least one comparison is included
ks_fc <- lapply(ks_res, function(x) na.exclude(x[["FC"]]))
names(ks_fdrcut) <- names(ks_fc) <- paste0("M", 1:9)
ks_fccut <- lapply(names(ks_fc), function(x) ks_fc[[x]][rownames(ks_fc[[x]]) %in% rownames(ks_fdrcut[[x]]), ])
ks_fccut <- lapply(ks_fccut, function(x) x[abs(rowSums(x)) > 0, ])
#Combine FDR df from all modules into one df
all_ks <- bind_rows(lapply(ks_fdrcut, function(x) as.data.frame(cbind("gene" = rownames(x), x))))
rownames(all_ks) <- all_ks$gene
all_ks <- all_ks[, -1]
gene_names <- rownames(all_ks)
all_ks <- sapply(all_ks, function(x) as.numeric(as.character(x)))
rownames(all_ks) <- gene_names
#Annotate each gene to corresponding module
anno_row <- bind_rows(lapply(names(ks_fdrcut), function(x) as.data.frame(cbind("gene" = rownames(ks_fdrcut[[x]]), "module" = x) )))
rownames(anno_row) <- anno_row$gene
anno_col <- list(celltype = ggcolours)
#Calculate breaks in heatmap based on modules
indices <- sapply(ks_fdrcut, nrow)
for(i in 2:length(indices)) {
x <- as.numeric(indices[i])
indices[i] <- as.numeric(indices[i - 1]) + as.numeric(indices[i])
}
cell_anno <- as.data.frame(colnames(all_ks))
colnames(cell_anno) <- "celltype"
rownames(cell_anno) <- cell_anno$celltype
use_breaks <- get_htmap_breaks(all_ks)
#+ ks_heatmap_manual, warning = F, message = F, width = 8, height = 10, fig.cap = "Cell-types are manually annotated."
p <- pheatmap(all_ks,
# border_color = "black",
color = colorRampPalette(c("darkmagenta", "snow2"))(250),
annotation_col = cell_anno[, 1, drop = F],
cluster_rows = F,
cluster_cols = T,
# scale = "row",
annotation_colors = anno_col,
gaps_row = indices,
show_rownames = F
# labels_col = paste(cell_anno$cluster, cell_anno$celltype),
# breaks = use_breaks2,
)
save_phtmap_pdf(p, "output_files/pit_utr_module_cheung_scrna_ks_FDR_cellenrichment_manual_anno.pdf", 8, 10)
print(p)
tmp <- dev.off()
# Create colour palette for heatmap annotation of cell types
ggcolours <- hue_pal()(12)
names(ggcolours) <- levels(manclusters)
celltypes_col <- celltypes
for(i in 1:length(celltypes_col)) {
celltypes_col[i] <- ggcolours[celltypes_col[i]]
}
names(celltypes_col) <- as.character(celltypes)
#' ## Run KS test for all cell clusters
#' KS test is run and FDR is calculated for each module gene in each cell cluster (not manually labelled).
#' Genes with enriched with FC > 0, FDR adj < 0.05 in at least one cell cluster compared to all other clusters are retained.
#' Heatmap is plotted with FDR value for each module gene retained in each cell cluster.
#+ run_ks_test, warning = F, message = F
#Run KS test and calculate FDR for each module gene
ks_res <- lapply(levels(mod_utr$modules), function(x) calc_stat_test(mod_utr[mod_utr$modules == x, "genename"], "ks", seurat, clusters))
#' # Enrichment of module genes in single cell populations
#' ## Setup data for enrichment test
#' Co-expression module gene data is loaded in.
#' A colour palette is made based on the cell-types.
#+ setup_modules_data, warning = F, message = F
#### Enrichment of module genes in single cell populations ####
seurat <- pit_seurat
# seuratman <- pit_seurat_manual
clusters <- seurat$RNA_snn_res.0.2
manclusters <- Idents(seurat)
mod_utr <- readRDS("input_files/pit_utrseq_coexpression_modules_annotation.rds")
# seuratman <- pit_seurat_manual
clusters <- seurat$SCT_snn_res.0.2
manclusters <- Idents(seurat)
mod_utr <- readRDS("input_files/pit_utrseq_coexpression_modules_annotation.rds")
mod_utr$modules <- factor(mod_utr$modules)
celltypes <- merge_cluster_ids
# Create colour palette for heatmap annotation of cell types
ggcolours <- hue_pal()(12)
names(ggcolours) <- levels(manclusters)
celltypes_col <- celltypes
for(i in 1:length(celltypes_col)) {
celltypes_col[i] <- ggcolours[celltypes_col[i]]
}
names(celltypes_col) <- as.character(celltypes)
#' ## Run KS test for all cell clusters
#' KS test is run and FDR is calculated for each module gene in each cell cluster (not manually labelled).
#' Genes with enriched with FC > 0, FDR adj < 0.05 in at least one cell cluster compared to all other clusters are retained.
#' Heatmap is plotted with FDR value for each module gene retained in each cell cluster.
#+ run_ks_test, warning = F, message = F
#Run KS test and calculate FDR for each module gene
ks_res <- lapply(levels(mod_utr$modules), function(x) calc_stat_test(mod_utr[mod_utr$modules == x, "genename"], "ks", seurat, clusters))
ks_respval <- lapply(ks_res, function(x) na.exclude(x[["pval"]]))
num_comparisons <- sum(unlist(lapply(ks_respval, function(x) print(as.numeric(dim(x)[1]) * as.numeric(dim(x)[2])))))
#Calculate FDR adjusted pvalue and filter for minimum FDR adj < 0.05 in each row
ks_resfdr <- lapply(ks_respval, function(x) matrix(p.adjust(as.matrix(x), method = "fdr", n = sum(num_comparisons)), nrow = nrow(x), ncol = ncol(x), dimnames = dimnames(x)))
ks_fdrcut <- lapply(ks_resfdr, function(x) x[rowMin(x) <= 0.05, ])
names(ggcolours) <- levels(manclusters)
celltypes_col <- celltypes
for(i in 1:length(celltypes_col)) {
celltypes_col[i] <- ggcolours[celltypes_col[i]]
}
names(celltypes_col) <- as.character(celltypes)
ggcolours
#' ## Run KS test for all cell clusters
#' KS test is run and FDR is calculated for each module gene in each cell cluster (not manually labelled).
#' Genes with enriched with FC > 0, FDR adj < 0.05 in at least one cell cluster compared to all other clusters are retained.
#' Heatmap is plotted with FDR value for each module gene retained in each cell cluster.
#+ run_ks_test, warning = F, message = F
#Run KS test and calculate FDR for each module gene
ks_res <- lapply(levels(mod_utr$modules), function(x) calc_stat_test(mod_utr[mod_utr$modules == x, "genename"], "ks", seurat, clusters))
View(ks_res)
pitman_countmat <- pit_seurat@assays$SCT@scale.data
View(pitman_countmat)
